#include<vector>
#include<iostream>
using namespace std;

const int MAXV = 510; //最大顶点数
const int INF = 1000000000;

int G[MAXV][MAXV]; //邻接矩阵
int d[MAXV]; //记录最短距离
int n, m, st, ed; //n为起点数，m为边数，st为起点，ed为终点
vector<int> pre[MAXV];
bool vis[MAXV] = {false};

void dijkstra(int s)
{
  fill(d, d+MAXV, INF);
  d[s] = 0;
  
  for(int i = 0; i < n, i++){
    int u = -1, MIN = INF;
    for(int j = 0; j < n; j++){
      if(vis[j] == false && d[j] < MIN){
        u = j;
        MIN = d[j];
      }
    }
    
    if(u == -1) return;
    vis[u] = true;
    for(int v = 0; v < n; v++){
      if(G[u][v] != INF){      //算法笔记p383还有vis[v] == false;这一条件，不太理解
        if(d[u] + G[u][v] < d[v]){
          d[v] = d[u] + G[u][v];
          pre[v].clear();
          pre[v].push_back(u);
        }else if(d[u] + G[u][v] = d[v]){
          pre[v].push_back(u);
        }
      }
    }
  }
}



